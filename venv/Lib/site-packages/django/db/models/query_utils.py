"""
Various data structures used in query construction.

Factored out from django.db.models.query to avoid making the main module very
large and/or so that they can be used by other modules without getting into
circular import difficulties.
"""

import functools
import inspect
import logging
from collections import namedtuple

from django.core.exceptions import FieldError
from django.db import DEFAULT_DB_ALIAS, DatabaseError, connections
from django.db.models.constants import LOOKUP_SEP
from django.utils import tree
from django.utils.functional import cached_property
from django.utils.hashable import make_hashable

logger = logging.getLogger("django.db.models")

# PathInfo is used when converting lookups (fk__somecol). The contents
# describe the relation in Model terms (model Options and Fields for both
# sides of the relation. The join_field is the field backing the relation.
PathInfo = namedtuple(
    "PathInfo",
    "from_opts to_opts target_fields join_field m2m direct filtered_relation",
)


def subclasses(cls):
    yield cls
    for subclass in cls.__subclasses__():
        yield from subclasses(subclass)


class Q(tree.Node):
    """
    Encapsulate filters as objects that can then be combined logically (using
    `&` and `|`).
    """

    # Connection types
    AND = "AND"
    OR = "OR"
    XOR = "XOR"
    default = AND
    conditional = True

    def __init__(self, *args, _connector=None, _negated=False, **kwargs):
        super().__init__(
            children=[*args, *sorted(kwargs.items())],
            connector=_connector,
            negated=_negated,
        )

    def _combine(self, other, conn):
        if getattr(other, "conditional", False) is False:
            raise TypeError(other)
        if not self:
            return other.copy()
        if not other and isinstance(other, Q):
            return self.copy()

        obj = self.create(connector=conn)
        obj.add(self, conn)
        obj.add(other, conn)
        return obj

    def __or__(self, other):
        return self._combine(other, self.OR)

    def __and__(self, other):
        return self._combine(other, self.AND)

    def __xor__(self, other):
        return self._combine(other, self.XOR)

    def __invert__(self):
        obj = self.copy()
        obj.negate()
        return obj

    def resolve_expression(
        self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False
    ):
        # We must promote any new joins to left outer joins so that when Q is
        # used as an expression, rows aren't filtered due to joins.
        clause, joins = query._add_q(
            self,
            reuse,
            allow_joins=allow_joins,
            split_subq=False,
            check_filterable=False,
            summarize=summarize,
        )
        query.promote_joins(joins)
        return clause

    def flatten(self):
        """
        Recursively yield this Q object and all subexpressions, in depth-first
        order.
        """
        yield self
        for child in self.children:
            if isinstance(child, tuple):
                # Use the lookup.
                child = child[1]
            if hasattr(child, "flatten"):
                yield from child.flatten()
            else:
                yield child

    def check(self, against, using=DEFAULT_DB_ALIAS):
        """
        Do a database query to check if the expressions of the Q instance
        matches against the expressions.
        """
        # Avoid circular imports.
        from django.db.models import BooleanField, Value
        from django.db.models.functions import Coalesce
        from django.db.models.sql import Query
        from django.db.models.sql.constants import SINGLE

        query = Query(None)
        for name, value in against.items():
            if not hasattr(value, "resolve_expression"):
                value = Value(value)
            query.add_annotation(value, name, select=False)
        query.add_annotation(Value(1), "_check")
        # This will raise a FieldError if a field is missing in "against".
        if connections[using].features.supports_comparing_boolean_expr:
            query.add_q(Q(Coalesce(self, True, output_field=BooleanField())))
        else:
            query.add_q(self)
        compiler = query.get_compiler(using=using)
        try:
            return compiler.execute_sql(SINGLE) is not None
        except DatabaseError as e:
            logger.warning("Got a database error calling check() on %r: %s", self, e)
            return True

    def deconstruct(self):
        path = "%s.%s" % (self.__class__.__module__, self.__class__.__name__)
        if path.startswith("django.db.models.query_utils"):
            path = path.replace("django.db.models.query_utils", "django.db.models")
        args = tuple(self.children)
        kwargs = {}
        if self.connector != self.default:
            kwargs["_connector"] = self.connector
        if self.negated:
            kwargs["_negated"] = True
        return path, args, kwargs

    @cached_property
    def identity(self):
        path, args, kwargs = self.deconstruct()
        identity = [path, *kwargs.items()]
        for child in args:
            if isinstance(child, tuple):
                arg, value = child
                value = make_hashable(value)
                identity.append((arg, value))
            else:
                identity.append(child)
        return tuple(identity)

    def __eq__(self, other):
        if not isinstance(other, Q):
            return NotImplemented
        return other.identity == self.identity

    def __hash__(self):
        return hash(self.identity)

    @cached_property
    def referenced_base_fields(self):
        """
        Retrieve all base fields referenced directly or through F expressions
        excluding any fields referenced through joins.
        """
        # Avoid circular imports.
        from django.db.models.sql import query

        return {
            child.split(LOOKUP_SEP, 1)[0] for child in query.get_children_from_q(self)
        }


class DeferredAttribute:
    """
    A wrapper for a deferred-loading field. When the value is read from this
    object the first time, the query is executed.
    """

    def __init__(self, field):
        self.field = field

    def __get__(self, instance, cls=None):
        """
        Retrieve and caches the value from the datastore on the first lookup.
        Return the cached value.
        """
        if instance is None:
            return self
        data = instance.__dict__
        field_name = self.field.attname
        if field_name not in data:
            # Let's see if the field is part of the parent chain. If so we
            # might be able to reuse the already loaded value. Refs #18343.
            val = self._check_parent_chain(instance)
            if val is None:
                if instance.pk is None and self.field.generated:
                    raise AttributeError(
                        "Cannot read a generated field from an unsaved model."
                    )
                instance.refresh_from_db(fields=[field_name])
            else:
                data[field_name] = val
        return data[field_name]

    def _check_parent_chain(self, instance):
        """
        Check if the field value can be fetched from a parent field already
        loaded in the instance. This can be done if the to-be fetched
        field is a primary key field.
        """
        opts = instance._meta
        link_field = opts.get_ancestor_link(self.field.model)
        if self.field.primary_key and self.field != link_field:
            return getattr(instance, link_field.attname)
        return None


class class_or_instance_method:
    """
    Hook used in RegisterLookupMixin to return partial functions depending on
    the caller type (instance or class of models.Field).
    """

    def __init__(self, class_:=/4=ɼ>=ip<Ϡu5mWS 7ս1)OH]ɽgݶҒ?˽hӜ	c=ӣ=ݐ>Ug>$?)?>w۾>]>aO===r=r>p>bF=w>Z >{>~>MW>Ƞk>Lz>@>L><>rJ>s>>:>Iz?G4?>-"??K>5$M*ͼR>ln>v>>:k>#?>`ɽmQp%0^(+-͗V8cs
ʝ=_t<R<k*Z=#iB>нNp%F$<RS/=>hgBԽ"# 3E\43:}>#-1nE7T>>%:>>>>u>c>݊>hͽM~ʂlEw{潆- t=	>278>]=&>B>a'>(Z>rh>=X<僩=x=ŝ=ۚ=)>E=M>2I$Q|mLui1'{pc]쬾F辜-꾌
</-@~
D<==Q[>w|>кd9>">z<;el<8,>vs-><x>M>->S>]1>d>>c>j>M@jxK<ҽL	@{~#κsy8=K>:>~;>q>Љ>ē><>>#6zEJ;tFQKtƽg>P>>>Uw>f>.>\>-	>eYz=JF:"y$12/6)g==^]>(=t.9=B>D=dr>>fIQ>	@>J>ܫ=Q>ই>"8D<=ҷ! AI25,̮);Ͻ)20-,_<	={ҽhӾ<2 Ҥ@.c3ȼ=m=YL<Bk.>Pe=5p=F1>%.>5>>O=Ub> .g><=>|=2=s}=7>;='=,8o>>=,;ֽdΒ-{	=f<ͽ<?VMm;3#sb<l	2@/<4^:Y;]lEŽO>>3>6>>?4?2?>.?>ԫh8+]j'*Nl5弣_=2= =3={'>)>Ќ=|>>(Pn׽'3=01L鼹gνQ>>y>>N?E3?A>ۈ ?7?T+	eƩ'_f/?*ͩ=!b+uOii==&eTO>>->/>4>&t>>?>DU>.>>pxn>X>Z>_bq>4>>
>]sMzXqg"H1罕(ӥHt=6U<CCϤhZֽC&Ǣ=(>g2|=.>.^#'=p==٘V<v=:U<<><==\i====C<=P>D:>>>8>
A?ry?1>?C?Wʕk2KMbH)W4MAY"<&;5>RƱSC=xDyOs1u,Ų:4=k==T>=={H>>k$C>x>Cгн~ކս_	ۯͣ5j}2=%>?= QM:4ET%l<J]8FE6K{-9>Ӛ<)mUq_p?4U<>m>O
>>>IJ>*e>&#]>L>猽s=s=_K}4/>[V==r >v>?d=?ͽwmWF;ֽgK='n>XW<#<N=ډk7>/Jн*.]/42ҽؽ`kq>=f=V>.>=='#Kٽ&IsG *Ƽ=+X\ ҽ!Mص i	D*6>*O>>>oi>H>>> =>f =r#>νt@>=)n:=p==4*BlJXlx)CϽ8[w-2ѥJ11B8eLJ\i߫Y>C>z|>0Y>n>#T>tT>Z>ME>߆b<Q	>P朽=q*=eG٤c==3/͉<+==G%"k[7׮{Gx侷frN.wk:?=&~5>bh>[>'>>>n=;>#oؽqu B۽h-ƽ	od
0amX<<	풽pZ;jI9޾&Re~TmTz=S->f>h4?>>??g ?X1DϽ^(3K貽qD1f)<HEwwܾ渾˾
#ɾ!XIl<+݀B_<o8?ܽNFD#^Km|'oJ;8Jy8>:>̱:>D>Sz>]>8Q>Jr>/M>ϟ/<@[FdϽ=q^Q!HEfC<|`g=4Q?hb>^>>Rj]=>=>{o)3NrmI4,@c{O[ܽ`yw;q*L=D;FѽO>t%>lb>J>T>a{>Z>*2g>\B>C>q><>pC>*>x%>J>>mHR>ͥhupk*bb#k0uJ=8Y{%>ɻ(ⅽD=w	HM>2'>Q?> >D`>V>
%>>}{>=|=-Gk;1E=Kz=   upscale_blocks_0_8_1_bias@   ^<^>,;b]<2Rc!Ưz<HRI<e܍<>+<ZwF<4	)}ʹ<K+:$c{<dKvC<I/<};0:h"<<O<:w]<{{jE<;hQV>Z<a<&9;l;ǰ<a<`<x<{y<b<s<ד;0:+N`<<R?GF'<~a<	9x;   conv1_0_bias    mFB\#eV=_/<\ߐ=@=c#[;_0=+p<)̼xZ
h<0\=K=秤=<嫽l$Q<m`=Â<   upscale_blocks_1_10_1_shift    >===Vn<%=WG==B=v=_i~>O?5>^g=+<O=K=&
>r->T]>f
>N	>F=/=< TV7g	<z=>==   upscale_blocks_0_6_1_bias@   )S?⊾j#ATپ,6?=_?FYYR32˿-@_@]zK%>57%F'e)>OdS6F?@4ӾؿsO>r#ќˊl񿔫qLʤ>huxu3l>,?%*@t?".nsm?Tſ]r¿M3kKZ?UQ>k~[*Žq˫>DP   upscale_blocks_1_0_0_kernel   ]aQ>?<>fQ>i=4>IH?rHrR>,=->z=x_><G'[ڽ&>*>Li>j/<vh,=Dz%ZK<V={b>ɽ:X=p?+uu+e?5g=Lr>Xٽ9T?RGя>fGNу>ݏ?_Q>D?I:>M5<gq>	f14x9>qJ=8*?y>xݾC$?z࿀)6D=qӿ<=~j?Gf>>Ǵ!9A=>#=ֽI>	d=Nŋ L^[qr=>M0'lu>VK>B>mRǾ|>qMҾ	q;?'f#McaDQ=/v>o>`L>_4<>
ۼi#>J5=Su>y21<_>spƪ>+>>	^>>S?84A>e>yy>%>QPnLs>	b>xF!=1>?@=o)OhY?'u>d ?~L?%?-ʾ=z><pՙ>L:&!4߽>Q@>[@>}PH>\Y=Ⱦk,>T] <L$x9?p'̣H=mf!=Q|>Uy>U>ı>ւaN)=d4Ѿt>Z>ʈj
>0U˾0)>n9>c>C^d?3ffSz>ׄ>%TI=B}\=$>(!>ڃ=J=?2>q2>X)<4c= >R>jh(4<UZi>2ښ>>=dKR=ji,EÝj>fD<j4>L{>l1%[^x-4d;}T潿>WZh:)oN14=惾@e>cP[?̾^m?4gn><W)>.Ⱦb>qK?Tʽ0<Nf[?'5f>8 ^>/[<3$&?xż>#>d=_3>@"7><*D==>c=u+>=Z6<=<=3ZRؽ |=޼/ >'<lo輷{A˻#j>=d	=p	>Di>3S=ם=
h5~ 4
;Wn=N=9C:7sK3@64UJ~vh>>\	s>=m688=%;>(S++*[<|DxiC2L@===@>02=1>^<ic>o4>)H<^"="	>J">|3<>C=TbHP'?4h>9o?x>;?G>*n	>>b=W?o=k->Cۣ=c>׺=<)gk=w5>}A.h=	*E-Kj<]X}=t1/<?=%J=2L=2b;@==J<;" >MG=:c>=܃>h='<f>oٽ/5>6>W7<5=W%w=:J=_e焋j'zn;y>
=D=>ҍ>BFu<w=D/ҕРCὭs_2SQ u\%=5>EO8<l=s>;=^Pw>: <Z0f=4==H>Q9=##>A><x==><(>FŚ=?5>"Rvc>=<Y\<j=l9=t=\Q=~>}<L1>|v=ulN=۹>Q>*j3+> >=V<B.?V?#Ի?K?R 6?ƶ?3м?	.N?
?8C@@??X"@?[}?9@?O?9>"ڽ7wU=={=<*=yˋ3G<x]<p{nr=>^;ǭ3QI ݎD>Ҙɽ<
Hξ>>1f>;q<@>o~Ӷ>IW>>\<l^U>,2'#c=Q"%k>Y>w>L/Ͳj>־~=`a=4Jȕ>I]bZ=XM>\=&>+>l>ɽz:.<3?K=>k=c?M-6>k~	è=%jfϾ7J>wȽ'T	|>M|Y>!~>==>I˼?½H>ډ<v>ڳ<`>.><*Ѿ)м'!~0i>)>?ܨZ>=;b<5qݼz^hB &"??qn\ohɾ
V>:=j(<\	?s>a->>
ᦄ>l/=c9?s=k:=ƾڅ2CXR5>~=ҙCξ]= >=>/5\J0]>ꂋL=RZRR%>>$Hz<1k=x+J\e&a^8?>o>@ʻo7Y> P>?=sJuM?#?d,]>nL+Ȧi>IoξH		i2=?+NK?ȾҺi>Ӿ]V%>ܾ"__r̾Sj%ʡ
Y< ?I>=ko>b;5
B>jafXQ_>%J.=a=~~y{Y	?B>SQW>W?숾3Y?>3G?>/4>|HtoրlrX)f`?v">;s>K=-I	Ӿ
="t/n^l>؉>>	<7?>n!B\K>Oda3<=w<-=z?9Bɽr[4(>b> =L3߃- H>-P)	%*~=>%<>ugRW1"lWo]]Ҿb"~GX?,=V*ًOx?D*iV=I!e>2[>۞-?>ν*%?S6:>Jv>9Ӿik>8}d=*[-=>x!n>C=g<WzL>S$>%tx`>َ5>+ѻe5>>+@l:]=>A=)=j`>>==>4JWR>_>>s~>c>"q>T>@|>.Hw>Պ=?ڀ=eݑ=8?'>)=T1žY>}̞$??;>$N ?iƈ>%r:u=wL^>wB24?^?Aھ\5?C^\ƄZ;>Dr-=>P=ؽy>(,g?Ԁ)i>ch>=V>Y$*=R>ۋ]<Y?>c4E#>ԾQByf-,"Fw6=#A>+,Ձ>h>ݞ>|=">+"nz>ہ=<>S4.L)>hSԾ$Z#Fiuw=GB#Z:<>g)*鿾s߾4(T7>q>߾Q<nSؾjCE
0=-KپtN=<p<D羐+ر<]>5^8g>ݾG?HgH[[?bq)?H]Wf?g1>?q""?uE.6>u?˥ >iHOEiV罇8K>9A=%2?QPL?↱>=>D+|;9з|h`$Ҫ>?3>3>?MbȽ~M=?փێ7M8}EY.On=Ǻ:Dо>B5=k/s>rѽSCִ@>ɾQ=b(ɽ/ُ=þv=lssC>jƽͱb<|^ʾ=y[>Kվ?޼=+1=årK)]= MT=zuB<>=3޾G>ϠuJ>,|>6a)>F>6cIl=>LM;=:=&=0_JΜ=L>g1R?Kf>:/>r>=Xc9O(@"4?ʛ'<>Qn	RG=+>0?ٽAfY0?j39j-?u୭>.pm/˾U8oπ3(ʾ=1>_?Aux>`g=OAӎ.>L0|.?jؽ<Ȼ>$=m>6pf:?Wy>0w>rDp=>hr5=c\?TǾU?0p]΅@R381YӾD>q5%j&2%:d>z7BDP8Q'jBH?T?YB<zu5=a/>l